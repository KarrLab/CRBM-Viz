import {
  Controller,
  Inject,
  OnApplicationBootstrap,
  Post,
  UseInterceptors,
  UploadedFile,
  Body,
  HttpException,
  HttpStatus,
  Logger,
  Get,
  Param,
  Query,
} from '@nestjs/common';
import { FileInterceptor } from '@nestjs/platform-express';
import { AppService } from './app.service';
import { ClientProxy } from '@nestjs/microservices';
import {
  ApiOperation,
  ApiResponse,
  ApiConsumes,
  ApiBody,
} from '@nestjs/swagger';
import {
  SimulationDispatchSpec,
  OmexDispatchFile,
} from '@biosimulations/dispatch/datamodel';
import { v4 as uuid } from 'uuid';
import * as fs from 'fs';
import path from 'path';
import * as csv2Json from 'csv2json';
import * as request from 'sync-request';

interface Dic {
  [key: string]: {
    [key: string]: object[];
  };
}

interface DicArray {
  [key: string]: string[];
}

@Controller()
export class AppController implements OnApplicationBootstrap {
  private logger = new Logger(AppController.name);
  constructor(
    private readonly appService: AppService,
    @Inject('DISPATCH_MQ') private messageClient: ClientProxy
  ) {}

  @Post('dispatch')
  @ApiConsumes('multipart/form-data')
  @ApiOperation({ summary: 'Dispatch a simulation job' })
  @ApiResponse({
    status: 201,
    description: 'Dispatch status',
    type: Object,
  })
  // TODO: Create a custom decorator for this and move to shared libs
  @ApiBody({
    schema: {
      type: 'object',
      properties: {
        file: {
          type: 'string',
          description: 'Omex file to upload',
          format: 'binary',
        },
        simulator: {
          type: 'string',
          description: 'Simulator to use like COPASI/VCELL, etc',
        },
        simulatorVersion: {
          type: 'string',
          description:
            'Version of the selected simulator like 4.27.214/latest, etc',
        },
      },
    },
  })
  @UseInterceptors(FileInterceptor('file'))
  uploadFile(
    @UploadedFile() file: OmexDispatchFile,
    @Body() bodyData: SimulationDispatchSpec
  ) {
    // TODO: Replace with fileStorage URL from configModule (BiosimulationsConfig)
    // TODO: Create the required folders automatically
    const fileStorage = process.env.FILE_STORAGE;
    const omexStorage = `${fileStorage}/OMEX/ID`;

    if (bodyData.simulator === '') {
      return { message: 'No Simulator was provided' };
    }

    // Get existing filetype
    // Generate a unique filename
    const fileId = uuid();
    const uniqueFilename = `${fileId}.omex`;
    const omexSavePath = path.join(omexStorage, uniqueFilename);

    // Fill out info from file that will be lost after saving in central storage
    const simSpec: SimulationDispatchSpec = {
      simulator: bodyData.simulator,
      simulatorVersion: bodyData.simulatorVersion,
      filename: file.originalname,
      uniqueFilename,
      filepathOnDataStore: omexSavePath,
    };

    // Save the file
    fs.writeFileSync(omexSavePath, file.buffer);

    this.messageClient.send('dispatch', simSpec).subscribe(
      (res) => {
        this.logger.log(JSON.stringify(res));
      },
      (err) => {
        this.logger.log(
          'Error occured in dispatch service: ' + JSON.stringify(err)
        );
      }
    );
    this.logger.log(
      'Dispatch message was sent successfully' + JSON.stringify(simSpec)
    );

    return {
      message: 'File uploaded successfuly',
      data: {
        id: fileId,
        filename: uniqueFilename,
      },
    };
  }

  @Get('result/:uuid')
  @ApiResponse({
    status: 200,
    description: 'Get Simulation Results',
    type: Object,
  })
  getVisualizationData(
    @Param('uuid') uId: string,
    @Query('chart') chart: boolean
  ) {
    const jsonResults: Dic = {};
    const fileStorage = process.env.FILE_STORAGE || '';

    const csvFilePath = path.join(fileStorage, 'simulations', uId, 'out');

    const directoryList = fs.readdirSync(csvFilePath);
    // NOTE: job.output is the Log file generated by the SBATCH simulation job
    const logFileIndex = directoryList.indexOf('job.output');
    directoryList.splice(logFileIndex);

    directoryList.forEach((directoryName: string) => {
      const fileList = fs.readdirSync(path.join(csvFilePath, directoryName));

      fileList.forEach(async (filename: string) => {
        if (filename.endsWith('csv')) {
          const taskName = filename.split('.csv')[0];
          const filePath = path.join(csvFilePath, directoryName, filename);
          this.logger.log('Reading file: ' + filePath);

          if (jsonResults[directoryName] === undefined) {
            jsonResults[directoryName] = {};
          }

          const jsonPath = filePath.split('.csv')[0] + '.json';

          const jsonResult: object[] = [];
          setTimeout(() => {
            fs.createReadStream(filePath)
              .pipe(
                csv2Json.default({
                  separator: ',',
                })
              )
              .pipe(fs.createWriteStream(jsonPath));
          }, 0);

          const fileContent = fs.readFileSync(jsonPath);
          jsonResults[directoryName][taskName] = JSON.parse(
            fileContent.toString()
          );
        }
      });
    });
    return {
      message: 'Data fetched successfully',
      data: chart ? this.convertJsonDataToChartData(jsonResults) : jsonResults,
    };
  }

  convertJsonDataToChartData(data: any) {
    const finalRes = JSON.parse(JSON.stringify(data));
    const sedmls = Object.keys(data);
    let tasks: Array<string> = [];
    // sedmls.forEach(sedml => {
    //   finalRes.set(sedml, {});
    // })

    sedmls.forEach((sedml) => {
      tasks = Object.keys(data[sedml]);
      tasks.forEach((task) => {
        finalRes[sedml][task] = {};
      });
    });

    for (const sedml of sedmls) {
      for (const task of tasks) {
        const taskKeys = Object.keys(data[sedml][task][0]);
        taskKeys.splice(taskKeys.indexOf('time'), 1);

        for (const taskKey of taskKeys) {
          finalRes[sedml][task][taskKey] = {};
          finalRes[sedml][task][taskKey]['x'] = [];
          finalRes[sedml][task][taskKey]['y'] = [];
          finalRes[sedml][task][taskKey]['type'] = 'scatter';
        }

        for (const dataObj of data[sedml][task]) {
          for (const taskKey of taskKeys) {
            finalRes[sedml][task][taskKey]['x'].push(dataObj['time']);
            finalRes[sedml][task][taskKey]['y'].push(dataObj[taskKey]);
          }
        }
      }
    }

    return finalRes;
  }

  @Get('simulators')
  @ApiResponse({
    status: 200,
    description: 'Get all simulators and their versions',
    type: Object,
  })
  getAllSimulatorVersion() {
    // NOTE: Add more simulators once they are supported
    const allSimulators = [
      'COPASI',
      'VCell',
      'Tellurium',
      'BioNetGen',
      'CobraPy',
    ];
    const simulatorAndVersions: DicArray = {};
    allSimulators.forEach((simulator: string) => {
      const simulatorName = `biosimulations_${simulator.toLowerCase()}`;
      const res = request.default(
        'GET',
        `https://registry.hub.docker.com/v1/repositories/crbm/${simulatorName}/tags`
      );
      const stringResponse: any = res.getBody().toString('utf8');
      const versions: Array<string> = [];
      JSON.parse(stringResponse).forEach((element: any) => {
        versions.push(element['name']);
      });
      simulatorAndVersions[simulator] = versions;
    });
    return {
      message: 'Simulator information fetched successfully',
      data: simulatorAndVersions,
    };
  }

  async onApplicationBootstrap() {
    await this.messageClient.connect();
    // console.log(this.getAllSimulatorVersion())
  }
}
