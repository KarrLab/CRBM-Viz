#!/usr/bin/env python3

import argparse
import json
import os
import requests
import requests.adapters
import requests.exceptions
import urllib3.util.retry

EXAMPLE_SIMULATIONS_RUNS_FILENAME = os.path.join(os.path.dirname(__file__),
                                                 '..', 'apps', 'dispatch', 'src', 'app', 'components',
                                                 'simulations', 'browse', 'example-simulations.{}.json')


def get_api_endpoint(biosimulations_api):
    """ Get the endpoint for checkin gthe status of each simulation run

    Args:
        biosimulations_api (:obj:`str`): API to use to check the status of each run
            (``dev``, ``org``, or ``local``)

    Returns:
        :obj:`str`: endpoint for checkin gthe status of each simulation run
    """
    if biosimulations_api == 'local':
        return 'http://localhost:3333'

    return 'https://api.biosimulations.{}'.format(biosimulations_api)


def get_failed_runs(examples_api, biosimulations_api):
    """ Get a list of any example simulation runs that didn't succeed

    Args:
        examples_api (:obj:`str`): example set to test (``dev`` or ``org``)
        biosimulations_api (:obj:`str`): API to use to check the status of each run
            (``dev``, ``org``, or ``local``)

    Returns:
        :obj:`list` of :obj:`str`: ids and names of failed simulation runs
    """

    # get name of file with runs
    filename = EXAMPLE_SIMULATIONS_RUNS_FILENAME.format(examples_api)

    # read simulation runs
    with open(filename, 'r') as file:
        runs = json.load(file)

    # check the status of each run
    base_endpoint = get_api_endpoint(biosimulations_api)
    failures = []
    for run in runs:
        # check status
        endpoint = '{}/runs/{}'.format(base_endpoint, run['id'])
        try:
            response = requests.get(endpoint)
            response.raise_for_status()
            status = response.json()['status']
            if status != 'SUCCEEDED':
                failures.append('`{}`: `{}`: [status]({}) (`{}`): {}'.format(examples_api, run['id'], endpoint, status, run['name']))
                continue
        except requests.exceptions.RequestException:
            failures.append('`{}`: `{}`: [status check]({}): {}'.format(examples_api, run['id'], endpoint, run['name']))
            continue

        # check COMBINE/OMEX archive
        endpoint = '{}/runs/{}/download'.format(base_endpoint, run['id'])
        try:
            response = requests.get(endpoint)
            response.raise_for_status()
        except requests.exceptions.RequestException:
            failures.append('`{}`: `{}`: [COMBINE download]({}): {}'.format(examples_api, run['id'], endpoint, run['name']))
            continue

        # check files
        endpoint = '{}/files/{}'.format(base_endpoint, run['id'])
        try:
            response = requests.get(endpoint)
            response.raise_for_status()
        except requests.exceptions.RequestException:
            failures.append('`{}`: `{}`: [files]({}): {}'.format(examples_api, run['id'], endpoint, run['name']))
            continue

        # check SED-ML specifications
        endpoint = '{}/specifications/{}'.format(base_endpoint, run['id'])
        try:
            response = requests.get(endpoint)
            response.raise_for_status()
        except requests.exceptions.RequestException:
            failures.append('`{}`: `{}`: [specifications]({}): {}'.format(examples_api, run['id'], endpoint, run['name']))
            continue

        # check metadata
        endpoint = '{}/metadata/{}'.format(base_endpoint, run['id'])
        try:
            response = requests.get(endpoint)
            response.raise_for_status()
        except requests.exceptions.RequestException:
            failures.append('`{}`: `{}`: [metadata]({}): {}'.format(examples_api, run['id'], endpoint,  run['name']))
            continue

        # check results
        retries = urllib3.util.retry.Retry(total=6, backoff_factor=5)
        retry_session = requests.Session()
        retry_session.mount(endpoint, requests.adapters.HTTPAdapter(max_retries=retries))

        endpoint = '{}/results/{}?includeData=false'.format(base_endpoint, run['id'])
        try:
            response = retry_session.get(endpoint)
            response.raise_for_status()
        except requests.exceptions.RequestException:
            failures.append('`{}`: `{}`: [results]({}): {}'.format(examples_api, run['id'], endpoint, run['name']))
            continue

        endpoint = '{}/results/{}/download'.format(base_endpoint, run['id'])
        try:
            response = requests.get(endpoint)
            response.raise_for_status()
        except requests.exceptions.RequestException:
            failures.append('`{}`: `{}`: [results download]({}): {}'.format(examples_api, run['id'], endpoint, run['name']))
            continue

        # check logs
        endpoint = '{}/logs/{}'.format(base_endpoint, run['id'])
        try:
            response = requests.get(endpoint)
            response.raise_for_status()
        except requests.exceptions.RequestException:
            failures.append('`{}`: `{}`: [logs]({}): {}'.format(examples_api, run['id'], endpoint, run['name']))
            continue

    # return list of failed runs
    return failures


if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        description='Check that all of the example simulation runs succeeded.'
    )
    parser.add_argument(
        '--runbiosimulations-api',
        type=str,
        default='dev',
        help='BioSimulations API which for projects should be checked (`dev`, `org`, `local`). Default: `dev`.'
    )
    args = parser.parse_args()

    examples_api = args.runbiosimulations_api
    if examples_api == 'local':
        examples_api = 'dev'
    failures = get_failed_runs(examples_api, args.runbiosimulations_api)

    if failures:
        msg = 'The following example simulation runs did not succeed:\n  * {}'.format('\n  * '.join(failures))
        raise SystemExit(msg)
    else:
        print('All example simulation runs succeeded!')
